
AI Agent Portal 开发技术文档 
1. 概述
1.3. 技术栈概览 (更新)
我们将采用以下主流且最新的技术栈：

前端: Vue.js 3 (Composition API, <script setup>), Vuetify v3, Pinia, Axios.
部署: Netlify (静态托管)。
后端: Node.js (Netlify Functions, TypeScript), TypeORM, PostgreSQL (托管服务), JWT.
AI 集成: RESTful API 调用，可能涉及 LangChain.js 或直接调用 OpenAI/其他大模型 API。
实时通信: 考虑使用客户端轮询 (Polling) 或独立的实时服务 (如 Supabase Realtime, Ably, Pusher)，因为 Netlify Functions 不支持持久的 WebSocket 连接。
2. 前端架构
前端负责用户界面的渲染、用户交互、数据展示和与后端 Netlify Functions 的通信。

2.1. 框架与库 (保持不变)
JavaScript 框架: Vue.js 3。
UI 组件库: Vuetify v3。
状态管理: Pinia。
路由: Vue Router 4。
HTTP 客户端: Axios。
2.3. 前端结构示例 (Vue 3 with <script setup>)
前端代码结构基本保持不变，但与后端 API 的交互将指向 Netlify Functions 提供的路径。例如，API 请求将发送到 /api/auth-login 而不是 /api/auth/login。

TypeScript


// views/Dashboard.vue (Example: Adjust API calls)
<script lang="ts" setup>
// ... existing imports ...

const fetchUserSettings = async (): Promise<void> => {
  try {
    // Adjust API endpoint for Netlify Function
    const response = await axios.get<UserPortalSettings>('/.netlify/functions/user-settings-get');
    userSettings.value = response.data;
    darkMode.value = response.data.theme === 'dark';
  } catch (error: any) {
    console.error('Error fetching user settings:', error);
    userSettings.value.layout = getDefaultWidgets();
  }
};

const saveSettings = async (): Promise<void> => {
  try {
    userSettings.value.theme = darkMode.value ? 'dark' : 'light';
    // Adjust API endpoint for Netlify Function
    const response = await axios.put<UserPortalSettings>('/.netlify/functions/user-settings-put', userSettings.value);
    console.log('Settings saved successfully');
    settingsPanelVisible.value = false;
  } catch (error: any) {
    console.error('Error saving settings:', error);
  }
};

// ... other code ...

// Real-time content updates will no longer use Socket.IO Client directly
// Instead, consider:
// 1. Polling: Periodically call an API function to get updates.
//    setInterval(async () => {
//      await fetchUserSettings(); // Or a specific widget data fetch
//    }, 5000); // Poll every 5 seconds
// 2. Or integrate with a dedicated real-time service client (e.g., Supabase Realtime client).
</script>
2.4. Netlify 前端部署配置 (netlify.toml)
在项目的根目录创建 netlify.toml 文件，以配置 Netlify 的构建和部署行为：

TOML


# netlify.toml
[build]
  # 前端构建命令，通常是 Vue CLI 或 Vite 的构建命令
  command = "pnpm run build" # 或者 "npm run build", "yarn build"
  # 构建输出目录，Vite/Vue CLI 默认是 dist
  publish = "dist"

[functions]
  # Netlify Functions 的源文件目录
  directory = "netlify/functions"
  # 指定 TypeScript 运行时，Netlify 会自动处理编译
  node_bundler = "esbuild" # esbuild 提供了更快的构建速度

[[redirects]]
  # 将所有 /api/ 前缀的请求重定向到 Netlify Functions
  from = "/.netlify/functions/*"
  to = "/.netlify/functions/:splat"
  status = 200

[[redirects]]
  # 路由回退，用于单页应用 (SPA)
  from = "/*"
  to = "/index.html"
  status = 200
3. 后端架构 (Netlify Functions + PostgreSQL)
后端现在将由一系列无服务器函数（Netlify Functions）构成，并使用 PostgreSQL 数据库。

3.1. 框架与库 (更新)
Node.js 运行时: Netlify Functions (基于 AWS Lambda)。
Web 框架: 不再是完整的 Express.js 应用，而是通过 Netlify Functions API (@netlify/functions) 响应 HTTP 请求。
TypeScript: 提供静态类型检查，增强代码质量和可维护性。
数据库: PostgreSQL。一种强大的关系型数据库，具有 ACID 特性，非常适合存储结构化数据。我们将使用托管的 PostgreSQL 服务（例如：Supabase PostgreSQL, Railway PostgreSQL, Render PostgreSQL, ElephantSQL 或 AWS RDS），因为 Netlify Functions 是无服务器的，不直接托管数据库。
ORM (对象关系映射): TypeORM。一个强大的 ORM，支持 TypeScript，可以让我们使用面向对象的方式与 PostgreSQL 数据库交互，替代了 Mongoose。
身份验证: JSON Web Tokens (JWT)。用于实现无状态的用户认证机制。
密码加密: bcryptjs。
AI 代理集成: LangChain.js 或直接调用 OpenAI API/其他大模型 API。
3.2. 后端结构示例 (Netlify Functions with TypeORM & PostgreSQL)
我们将不再有一个单一的 app.ts 文件，而是为每个 API 逻辑创建一个独立的 Netlify Function 文件。

项目结构示例:

Bash


.
├── netlify/
│   └── functions/
│       ├── auth-login.ts
│       ├── auth-register.ts
│       ├── user-settings-get.ts
│       ├── user-settings-put.ts
│       ├── ai-agent-command.ts
│       ├── utils/
│       │   └── database.ts       # TypeORM 连接配置
│       └── middleware/
│           └── auth-function.ts  # Netlify Functions 专用的认证中间件
├── src/ # 前端代码
│   ├── components/
│   ├── views/
│   ├── store/
│   ├── interfaces/             # 共享接口定义
│   │   ├── portal.ts
│   │   └── user.ts
│   └── main.ts
├── entities/                   # TypeORM 实体定义
│   ├── User.ts
│   └── PortalSetting.ts
├── netlify.toml
├── package.json
├── tsconfig.json
└── .env                        # 环境变量
共享接口 (src/interfaces/portal.ts & src/interfaces/user.ts)

确保前端和后端（Netlify Functions）都可以访问这些类型定义。

TypeScript


// src/interfaces/user.ts (共享接口)
export interface User {
  id?: string; // Change _id to id for PostgreSQL/TypeORM
  username: string;
  email: string;
  password?: string;
  createdAt?: Date;
  updatedAt?: Date;
}

// src/interfaces/portal.ts (共享接口)
export interface PortalWidget {
  id: string;
  type: 'text' | 'chart' | 'weather' | 'custom';
  title: string;
  position: { x: number; y: number; width: number; height: number; zIndex: number };
  minimized: boolean;
  maximized: boolean;
  fullscreen: boolean;
  config: Record<string, any>;
}

export interface UserPortalSettings {
  id?: string; // Primary key for PortalSetting
  userId: string; // Foreign key referencing User.id
  layout: PortalWidget[];
  theme: string;
  language: string;
  createdAt?: Date;
  updatedAt?: Date;
}
TypeORM 实体定义 (entities/User.ts, entities/PortalSetting.ts)

这些文件定义了数据库表结构和实体之间的关系。

TypeScript


// entities/User.ts
import { Entity, PrimaryGeneratedColumn, Column, BeforeInsert, BeforeUpdate, OneToOne } from 'typeorm';
import bcrypt from 'bcryptjs';
import { PortalSettingEntity } from './PortalSetting'; // Import for relation

@Entity('users') // PostgreSQL table name
export class UserEntity {
  @PrimaryGeneratedColumn('uuid') // Auto-generated UUID primary key
  id!: string;

  @Column({ unique: true })
  username!: string;

  @Column({ unique: true })
  email!: string;

  @Column()
  password!: string;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  createdAt!: Date;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  updatedAt!: Date;

  // One-to-one relationship with PortalSetting
  @OneToOne(() => PortalSettingEntity, portalSetting => portalSetting.user)
  portalSetting!: PortalSettingEntity;

  // Hash password before inserting or updating
  @BeforeInsert()
  @BeforeUpdate()
  async hashPassword(): Promise<void> {
    // Only hash if password field is provided and has changed
    // In update scenarios, you might only update password if explicitly provided
    if (this.password && (this as any).__password !== this.password) { // Use a hidden property to track original password
        this.password = await bcrypt.hash(this.password, 10);
        (this as any).__password = this.password;
    }
  }

  async comparePassword(candidatePassword: string): Promise<boolean> {
    return await bcrypt.compare(candidatePassword, this.password);
  }
}
TypeScript


// entities/PortalSetting.ts
import { Entity, PrimaryGeneratedColumn, Column, OneToOne, JoinColumn } from 'typeorm';
import { UserEntity } from './User';
import type { PortalWidget } from '../src/interfaces/portal'; // Reference shared interface

@Entity('portal_settings') // PostgreSQL table name
export class PortalSettingEntity {
  @PrimaryGeneratedColumn('uuid') // Auto-generated UUID primary key
  id!: string;

  // Foreign key column for UserEntity
  @Column({ name: 'userId', unique: true })
  userId!: string;

  @OneToOne(() => UserEntity, user => user.portalSetting, { onDelete: 'CASCADE' }) // If user is deleted, delete settings
  @JoinColumn({ name: 'userId' }) // Specifies the foreign key column
  user!: UserEntity; // Relation object, not the foreign key directly

  // Storing layout as JSONB for flexibility
  @Column('jsonb', { array: false, default: () => "'[]'" })
  layout!: PortalWidget[];

  @Column({ default: 'light' })
  theme!: string;

  @Column({ default: 'en' })
  language!: string;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP' })
  createdAt!: Date;

  @Column({ type: 'timestamp', default: () => 'CURRENT_TIMESTAMP', onUpdate: 'CURRENT_TIMESTAMP' })
  updatedAt!: Date;
}
数据库连接工具 (netlify/functions/utils/database.ts)

管理 TypeORM 的数据库连接。由于 Netlify Functions 是短生命周期的，我们需要确保每次函数调用时连接可用且避免重复初始化。

TypeScript


// netlify/functions/utils/database.ts
import { DataSource, Repository } from 'typeorm';
import { UserEntity } from '../../entities/User';
import { PortalSettingEntity } from '../../entities/PortalSetting';
import 'dotenv/config'; // Make sure .env variables are loaded

// Singleton DataSource instance
let AppDataSource: DataSource;

export const connectDB = async (): Promise<void> => {
  if (AppDataSource && AppDataSource.isInitialized) {
    return; // Already connected
  }

  AppDataSource = new DataSource({
    type: 'postgres',
    host: process.env.DB_HOST,
    port: parseInt(process.env.DB_PORT || '5432', 10),
    username: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false, // For production with hosted DB
    synchronize: false, // IMPORTANT: In production, use TypeORM Migrations instead of synchronize: true
    logging: process.env.NODE_ENV === 'development' ? ['query', 'error'] : false, // Log queries in dev
    entities: [UserEntity, PortalSettingEntity],
  });

  try {
    await AppDataSource.initialize();
    console.log('PostgreSQL DataSource initialized successfully.');
  } catch (error: any) {
    console.error('Error during DataSource initialization:', error);
    throw error; // Re-throw to indicate connection failure
  }
};

export const getRepository = <T>(entity: new () => T): Repository<T> => {
  if (!AppDataSource || !AppDataSource.isInitialized) {
    throw new Error('DataSource is not initialized. Call connectDB first.');
  }
  return AppDataSource.getRepository(entity);
};
Netlify Functions 认证中间件 (netlify/functions/middleware/auth-function.ts)

适用于 Netlify Function 的认证逻辑。

TypeScript


// netlify/functions/middleware/auth-function.ts
import { APIGatewayProxyEvent } from 'aws-lambda';
import jwt from 'jsonwebtoken';
import 'dotenv/config';

interface AuthResult {
  isAuthenticated: boolean;
  statusCode: number;
  message?: string;
  userId?: string;
}

export const authenticateToken = (event: APIGatewayProxyEvent): AuthResult => {
  const authHeader = event.headers.authorization;
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return { isAuthenticated: false, statusCode: 401, message: 'Unauthorized: No token provided' };
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET as string) as { userId: string; iat: number; exp: number };
    return { isAuthenticated: true, statusCode: 200, userId: decoded.userId };
  } catch (err) {
    console.error('Token verification error:', err);
    return { isAuthenticated: false, statusCode: 403, message: 'Forbidden: Invalid token' };
  }
};
Netlify Function 示例 (netlify/functions/auth-login.ts)

TypeScript


// netlify/functions/auth-login.ts
import { Handler, Context } from '@netlify/functions';
import { connectDB, getRepository } from '../utils/database';
import { UserEntity } from '../../entities/User';
import 'dotenv/config'; // Loads environment variables

const handler: Handler = async (event, context) => {
  if (event.httpMethod !== 'POST') {
    return { statusCode: 405, body: 'Method Not Allowed' };
  }

  try {
    await connectDB(); // Ensure DB connection
    const { email, password } = JSON.parse(event.body || '{}');

    if (!email || !password) {
      return { statusCode: 400, body: JSON.stringify({ message: 'Email and password are required' }) };
    }

    const userRepository = getRepository(UserEntity);
    const user = await userRepository.findOne({ where: { email } });

    if (!user) {
      return { statusCode: 400, body: JSON.stringify({ message: 'Invalid credentials' }) };
    }

    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return { statusCode: 400, body: JSON.stringify({ message: 'Invalid credentials' }) };
    }

    const token = jwt.sign({ userId: user.id }, process.env.JWT_SECRET as string, { expiresIn: '1h' });

    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ token, userId: user.id, username: user.username }),
    };
  } catch (error: any) {
    console.error('Login error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: 'Internal server error', error: error.message }),
    };
  }
};

export { handler };
Netlify Function 示例 (netlify/functions/user-settings-get.ts)

TypeScript


// netlify/functions/user-settings-get.ts
import { Handler, Context } from '@netlify/functions';
import { connectDB, getRepository } from '../utils/database';
import { PortalSettingEntity } from '../../entities/PortalSetting';
import { UserEntity } from '../../entities/User'; // Needed for relation
import { authenticateToken } from '../middleware/auth-function';
import 'dotenv/config';

const handler: Handler = async (event, context) => {
  if (event.httpMethod !== 'GET') {
    return { statusCode: 405, body: 'Method Not Allowed' };
  }

  const authResult = authenticateToken(event);
  if (!authResult.isAuthenticated) {
    return { statusCode: authResult.statusCode, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: authResult.message }) };
  }
  const userId = authResult.userId as string; // Assert userId is string

  try {
    await connectDB();
    const portalSettingRepository = getRepository(PortalSettingEntity);
    const userRepository = getRepository(UserEntity); // To find the user entity for creation

    let settings = await portalSettingRepository.findOne({ where: { userId } });

    if (!settings) {
      // If no settings found, create default settings
      const user = await userRepository.findOne({ where: { id: userId } });
      if (!user) {
          return { statusCode: 404, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: 'User not found' }) };
      }
      settings = portalSettingRepository.create({
        userId: user.id, // Link to the user's ID
        user: user,     // Assign the user entity to the relation
        layout: [],
        theme: 'light',
        language: 'en',
      });
      await portalSettingRepository.save(settings);
    }

    return {
      statusCode: 200,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(settings),
    };
  } catch (error: any) {
    console.error('Get user settings error:', error);
    return {
      statusCode: 500,
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: 'Internal server error', error: error.message }),
    };
  }
};

export { handler };
4. 核心功能实现细节 (更新)
4.1. 用户认证与授权 (更新)
Netlify Functions: 每个认证相关的 API 端点（注册、登录）都将是一个独立的 Netlify Function。
JWT: 生成和验证 JWT 的机制保持不变，但验证逻辑将集成到每个受保护的 Netlify Function 中。
4.2. 用户偏好与门户配置管理 (更新)
数据模型: PortalSettingEntity 和 UserEntity 使用 TypeORM 映射到 PostgreSQL 数据库中的表。layout 字段存储为 PostgreSQL 的 JSONB 类型，以保持灵活性。
API:
GET /.netlify/functions/user-settings-get: 获取当前用户的门户设置。
PUT /.netlify/functions/user-settings-put: 更新当前用户的门户设置。
实时更新: 由于 Netlify Functions 不支持持久的 WebSocket 连接，原有的 Socket.IO 实时推送将不再适用。替代方案包括：
客户端轮询 (Polling)：前端定期（例如每隔几秒）调用 /users-settings-get 或其他特定的数据获取函数，检查是否有更新。这是最直接的替代方案，但在数据不频繁更新时可能效率不高。
专用实时服务: 集成第三方实时服务（如 Supabase Realtime, Ably, Pusher）。这些服务在 Netlify Functions 环境下表现良好，但需要额外的服务配置和费用。
在 AI Agent 更改后客户端主动刷新: AI Agent 成功执行命令并更新数据库后，前端收到成功响应，可以主动触发一次数据获取（例如 fetchUserSettings()），以立即反映更改。
4.3. AI 代理集成 (更新)
Netlify Function: AI 代理命令处理将封装在一个 Netlify Function 中，例如 /.netlify/functions/ai-agent-command。
操作执行: AI Agent Function 接收用户命令，调用 AI 模型进行意图识别和参数提取，然后使用 TypeORM 更新 PostgreSQL 中的 PortalSettingEntity。
反馈与更新: AI Agent Function 返回处理结果给前端。如果门户配置发生更改，前端可以根据之前提到的实时更新策略（如轮询或在成功响应后立即刷新）来反映这些变化。
5. 开发与部署 (更新)
5.1. 开发环境
Node.js: LTS 版本 (例如 20.x)。
包管理器: pnpm (推荐) 或 npm/yarn。
代码编辑器: VS Code，配合 ESLint, Prettier, Vue Language Features (Volar), TypeORM 插件。
版本控制: Git。
本地开发: Netlify CLI (命令行工具) 可以用于在本地模拟 Netlify Functions 环境，并部署到 Netlify。
5.2. 代码规范与质量 (保持不变)
ESLint: 强制执行代码风格和最佳实践。
Prettier: 自动格式化代码。
TypeScript: 提高代码质量。
5.3. 测试 (更新)
单元测试:
前端: Vitest 或 Jest。
后端 (Netlify Functions): Jest，需要模拟数据库连接和环境变量。
端到端 (E2E) 测试: Cypress 或 Playwright，测试前端和部署后的 Netlify Functions。
5.4. 部署 (更新)
Netlify 部署:
自动构建与部署: 连接 Git 仓库 (GitHub, GitLab, Bitbucket) 到 Netlify。Netlify 会自动检测 netlify.toml 文件，并在每次代码提交时自动构建前端应用和 Netlify Functions，然后部署。
环境变量: 所有的敏感信息，如 DB_HOST, DB_PORT, DB_USER, DB_PASSWORD, DB_NAME, JWT_SECRET, OPENAI_API_KEY 等，都应在 Netlify UI 中配置为环境变量，而不要直接硬编码在代码中。Netlify Functions 会自动读取这些环境变量。
PostgreSQL 数据库托管:
选择一个可靠的托管 PostgreSQL 服务（如 Supabase, Railway, Render, ElephantSQL, AWS RDS）。
获取数据库的连接字符串和凭据，并将其配置为 Netlify 的环境变量。
TypeORM Migrations: 在生产环境中，强烈建议使用 TypeORM 的Migrations (数据库迁移) 功能来管理数据库 schema 的变更，而不是依赖 synchronize: true (这在生产环境中可能会导致数据丢失)。
6. 安全考虑 (更新)
HTTPS: Netlify 自动提供免费的 HTTPS。
输入验证: 前后端对所有用户输入进行严格验证。
CORS: Netlify Functions 默认的 CORS 策略通常与前端部署在同一域名下时不会有问题。如果前端与函数在不同域，需要确保在函数中设置正确的 Access-Control-Allow-Origin 头部。
CSRF 防护: 对于基于 JWT 的认证，通常不需要 CSRF token，因为 JWT 是在 Authorization 头部发送的，不易受到 CSRF 攻击。
XSS 防护: 对用户生成的内容进行清理和转义。
速率限制: Netlify Functions 有其自身的调用限制。对于关键的认证和 AI Agent API，可能需要在 Netlify 配置中或在函数内部实现自定义的速率限制。
敏感信息存储: 所有敏感凭据都存储为 Netlify 的环境变量，绝不提交到版本控制。
依赖项安全: 定期更新所有第三方库，并扫描漏洞。
数据库连接安全: 确保数据库服务配置了强密码，并限制了访问 IP 地址（如果托管服务支持）。
7. 总结 (更新)
通过将前端部署在 Netlify 进行静态托管，并将后端逻辑拆分为 Netlify Functions，结合 PostgreSQL 作为持久化数据库，我们将实现一个高度可扩展、易于部署且成本效益高的 AI Agent Portal。这种架构利用了无服务器的优势，简化了运维，并能根据实际负载自动扩缩容。同时，TypeScript 和 TypeORM 确保了代码质量和数据库操作的类型安全。对于实时功能，我们将根据项目需求选择最适合的方案，如客户端轮询或集成专用的实时服务。